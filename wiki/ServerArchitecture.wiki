#summary One-sentence summary of this page.

= Server Architecture =

[#Description Go to description]

[https://treebase.googlecode.com/svn/images/ServerArchitecture.PNG]

----
==Description==

=== Storage Subsystem ===

 The storage subsystem handles the [FileFormat#Page_Layer page layer] for each storage. Each database file is treated as a separate storage unit. [#Junction_Mechanism Junctions] are used to map all storages into the namespace. 
 Two storages are managed differently, than the ordinary storages related to files. The first storage is located in memory, it contains the [DatabaseStructure standard database sections]. These sections are volatile, so they are created each time, during the engine startup. The second is located in a temporary file. It is not mapped into namespace, but used internally for [ClientProgramming#Section_operations snapshots]. It is also prepared for future implementation of transactions.
 In case of file storage the separate thread is created for each file. It processes the requests of page loading into core cache of each storage unit. When the cache is full, the LRU pages are discarded, dirty discarded pages are stored in pre-write temporary file.

[https://treebase.googlecode.com/svn/images/StorageCaching.PNG]

|| *Related Classes* ||
|| {{{DataPage::TPageCache}}} ||
|| {{{Storage::TStorage}}} and subclasses ||
|| {{{Storage::TStorageHandlerTask}}}
|| {{{Storage::TDataFile}}} ||
|| {{{Storage::TTempFile}}} ||
|| {{{Storage::TAdvPageRef}}} ||

----
=== Segment Manager ===
 The segment manager is responsible for [FileFormat#Segment_Layer segment layer] handling. It translates in-segment relative pages numbers to absolute page numbers and _vice versa_, allocates space for new pages within segment, handles creation and deletion of segments.

|| *Related Functions And Classes* ||
|| {{{Storage::TStoragePageAlloc}}} ||
|| {{{TSegment}}} ||
|| {{{TAdvancedSegment}}} ||
|| {{{SEGMENT_*}}} functions ||

----
=== Database Page Compacting Daemon ===
 When some, not neccessarily adjacent pages are deleted, the structure of file is no longer contiguous, the gaps appear. It leads to situation, when the database file takes far more disk space, than it could.
 So, the compacting mechanism is very desirable. It is implemented in a separate thread, that is active only when no client application is running (it is achieved by lock of the {{{TDBManager}}} object).
 
|| *Related Classes* ||
|| {{{TCompactBase}}} ||
|| {{{TCompactTask}}} ||

----
=== Data Manager ===
 The task of data manager is to manage lower part of [FileFormat#Section_And_BLOB_Layer section layer]. Its code implements the structure of data blocks related to items, and associated operations such as adding, modifying, deleting items etc.

|| *Related Functions And Classes* ||
|| {{{TSectionSegment}}} ||
|| {{{TSectionSegmentCompact}}} ||
|| {{{Util::Segment::*}}} functions ||

----
=== Sections Handling ===
 The purpose of its subsystem is in order to handle upper part of [FileFormat#Section_And_BLOB_Layer section layer]. The [#Data_Manager data manager] itself does not understand the difference between section items and subsections. Just this module (Section Handling) manages the special treatment of subsections.
 Besides it is responsible for opening, closing sections and, resolving and other section operations.

|| *Related Functions And Classes* ||
|| {{{TSection}}} ||
|| {{{SECTION_*}}} functions ||

----
=== Junction Mechanism ===
 Only the memory storage is directly mapped into namespace "\". The other storages require some extra solutions to be visible in the namespace. It is the task of the junction mechanism.
 A *junction point* is a pair of source and target sections addresses represented by database and segment ID. 
{{{
source( databaseId, segmentId ) -> target(databaseId, segmentId )
}}}   
 When any found subsection matches a junction source, the translation is performed. 
 There are 2 kinds of junction points _global_ and _local_, that are used only by one thread. Junction points can be compound, that are both global and local. Let us consider _\!CurrentUser_. The segment corresponding to section _!CurrentUser_ on memory storages is first globally translated to reserved value ( -1, 10 ). Later it is locally translated to segment related current user.

