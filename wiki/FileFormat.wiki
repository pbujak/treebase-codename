#summary One-sentence summary of this page.

= File Format =

----
== Introduction ==

The data of each file can be considered on 3 separate layers: 
 * binary
 * segment
 * section and BLOB

|| *Page* || Basic unit of data, that can be loaded or stored to file (2048 bytes) ||
|| *Segment* || Logical sequence of pages (not neccessarily adjacent), that can be understood as a file in file ||

Each layer can be treated by a black box by others.

https://treebase.googlecode.com/svn/images/FileLayers.PNG

----
== Page Layer ==

 Pages are the atomic units of data, that are read or written to database file. Each page has an associated CRC code, which follows the data itself. Besides the simple encryption is used - pages are ciphered by XOR-ing by a variable length key (64-128 bytes), that is stored in file header. It is rather primitive algorithm, but sophisticated enough to make containing strings unable to be understood while direct file viewing.
 The file header is stored in page 0, but it is managed differently, than other pages. First its CRC is not stored after the whole page, but directly follows the header. Seconds the header is not encrypted, because the header itself contains the key.
 When any page is requested to be read, the whole group of 16 pages is prefetched and cached. While storing the adjacent pages are merged into groups, but not exceeding 16 pages.

https://treebase.googlecode.com/svn/images/FilePageLayer.PNG

 In case of in-memory and temporary storage the situation looks a litte differently. There is neither CRC computing nor encrypting in this case. In assumption these kinds of storage are not persistent, so data durability need not to be guaranted, but they should be as efficient as possoble.

----
== Segment Layer ==

 Segments are the logical, variable sized sequences of pages. Each member page has anumber relative to segment regardless of its absolute position within file. In order segments also have number identifiers. Generally the numbers are dynamically allocated while segment creation excluding reserved numbers.

<code language="C++">
#define SEGID_RESERVED   0x00FFFFFF
#define SEGID_TABLE      0x00FFFF01
#define SEGID_SEGMENTDIR 0x00FFFF02
#define SEGID_SECDATA    0x00FFFF03 
</code>
----
https://treebase.googlecode.com/svn/images/FileSegmentLogic.PNG

 The page relative order numbers within segments must be in any way translated into absolute order numbers in file. It is the task of page tables together with page directory. Each physical page (let us name it "A") has an associated entry in corresponding page table. This entry contains absolute address of page A's successor within segment or value 0, when page A is the last within segment. Each page table has 4096 entries. To match a proper table - the absolute page number is divided by 4096, the result is an index into dage table directory. The corresponding entry in the directory is an absolute number of first page of the proper page table.

https://treebase.googlecode.com/svn/images/FileSegmentLayout.PNG