<html>
<body style="font-family:Arial,Helvetica">

 <h1><a name="Server_Architecture"></a>Server Architecture<a href="#Server_Architecture" class="section_anchor"></a></h1><p><ul><li><a href="#Server_Architecture">Server Architecture</a></li><ul><li><a href="#Logical_Schema">Logical Schema</a></li><li><a href="#Description">Description</a></li><ul><li><a href="#Storage_Subsystem">Storage Subsystem</a></li><li><a href="#Segment_Manager">Segment Manager</a></li><li><a href="#Database_Page_Compacting_Daemon">Database Page Compacting Daemon</a></li><li><a href="#Data_Manager">Data Manager</a></li><li><a href="#Sections_Handling">Sections Handling</a></li><li><a href="#Junction_Mechanism">Junction Mechanism</a></li><li><a href="#Security_Manager">Security Manager</a></li><li><a href="#Session_Management_And_Authentication_Services">Session Management And Authentication Services</a></li><li><a href="#System_Status">System Status</a></li></ul></ul></ul> <hr/></p><h2><a name="Logical_Schema"></a>Logical Schema<a href="#Logical_Schema" class="section_anchor"></a></h2><p><img src="images/ServerArchitecture.PNG" /> </p><hr/><h2><a name="Description"></a>Description<a href="#Description" class="section_anchor"></a></h2><h3><a name="Storage_Subsystem"></a>Storage Subsystem<a href="#Storage_Subsystem" class="section_anchor"></a></h3><blockquote>The storage subsystem handles the <a href="FileFormat#Page_Layer">page layer</a> for each storage. Each database file is treated as a separate storage unit. <a href="#Junction_Mechanism">Junctions</a> are used to map all storages into the namespace.  
Two storages are managed differently, than the ordinary storages related to files. The first storage is located in memory, it contains the <a href="DatabaseStructure">standard database sections</a>. These sections are volatile, so they are created each time, during the engine startup. The second is located in a temporary file. It is not mapped into namespace, but used internally for <a href="ClientProgramming#Section_operations">snapshots</a>. It is also prepared for future implementation of <a href="FutureImprovements#Transactions">transactions</a>. 
In case of file storage the separate thread is created for each file. It processes the requests of page loading into core cache of each storage unit. When the cache is full, the LRU pages are discarded, dirty discarded pages are stored in pre-write temporary file. 
</blockquote><p><img src="images/StorageCaching.PNG" /> </p><p><table class="wikitable"><tr><td style="border: 1px solid #ccc; padding: 5px;"> <strong>Related Classes</strong> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>DataPage::TPageCache</tt> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>Storage::TStorage</tt> and subclasses </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>Storage::TStorageHandlerTask</tt> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>Storage::TDataFile</tt> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>Storage::TTempFile</tt> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>Storage::TAdvPageRef</tt> </td></tr> </table></p><hr/><h3><a name="Segment_Manager"></a>Segment Manager<a href="#Segment_Manager" class="section_anchor"></a></h3><blockquote>The segment manager is responsible for <a href="FileFormat#Segment_Layer">segment layer</a> handling. It translates in-segment relative pages numbers to absolute page numbers and <i>vice versa</i>, allocates space for new pages within segment, handles creation and deletion of segments. 
</blockquote><p><table class="wikitable"><tr><td style="border: 1px solid #ccc; padding: 5px;"> <strong>Related Functions And Classes</strong> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>Storage::TStoragePageAlloc</tt> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>TSegment</tt> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>TAdvancedSegment</tt> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>SEGMENT_*</tt> functions </td></tr> </table></p><hr/><h3><a name="Database_Page_Compacting_Daemon"></a>Database Page Compacting Daemon<a href="#Database_Page_Compacting_Daemon" class="section_anchor"></a></h3><blockquote>When some, not neccessarily adjacent pages are deleted, the structure of file is no longer contiguous, the gaps appear. It leads to situation, when the database file takes far more disk space, than it could. 
So, the compacting mechanism is very desirable. It is implemented in a separate thread, that is active only when no client application is running (it is achieved by lock of the <tt>TDBManager</tt> object). 
</blockquote><p>  <table class="wikitable"><tr><td style="border: 1px solid #ccc; padding: 5px;"> <strong>Related Classes</strong> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>TCompactBase</tt> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>TCompactTask</tt> </td></tr> </table></p><hr/><h3><a name="Data_Manager"></a>Data Manager<a href="#Data_Manager" class="section_anchor"></a></h3><blockquote>The task of data manager is to manage lower part of <a href="FileFormat#Section_And_BLOB_Layer">section layer</a>. Its code implements the structure of data blocks related to items, and associated operations such as adding, modifying, deleting items etc. 
</blockquote><p><table class="wikitable"><tr><td style="border: 1px solid #ccc; padding: 5px;"> <strong>Related Functions And Classes</strong> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>TSectionSegment</tt> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>TSectionSegmentCompact</tt> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>Util::Segment::*</tt> functions </td></tr> </table></p><hr/><h3><a name="Sections_Handling"></a>Sections Handling<a href="#Sections_Handling" class="section_anchor"></a></h3><blockquote>The purpose of its subsystem is in order to handle upper part of <a href="FileFormat#Section_And_BLOB_Layer">section layer</a>. The <a href="#Data_Manager">data manager</a> itself does not understand the difference between section items and subsections. Just this module (Section Handling) manages the special treatment of subsections. 
Besides it is responsible for opening, closing sections and, resolving and other section operations. 
</blockquote><p><table class="wikitable"><tr><td style="border: 1px solid #ccc; padding: 5px;"> <strong>Related Functions And Classes</strong> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>TSection</tt> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>SECTION_*</tt> functions </td></tr> </table></p><hr/><h3><a name="Junction_Mechanism"></a>Junction Mechanism<a href="#Junction_Mechanism" class="section_anchor"></a></h3><blockquote>Only the memory storage is directly mapped into namespace &quot;\&quot;. The other storages require some extra solutions to be visible in the namespace. It is the task of the junction mechanism. 
A <strong>junction point</strong> is a pair of source and target sections addresses represented by database and segment ID.  
<pre class="prettyprint">source( databaseId, segmentId ) -&gt; target(databaseId, segmentId )</pre>When any found subsection matches a junction source, the translation is performed.  
There are 2 kinds of junction points <i>global</i> and <i>local</i>, that are used only by one thread. Junction points can be compound, that are both global and local. Let us consider <i>\CurrentUser</i>. The segment corresponding to section <i>CurrentUser</i> on memory storages is first globally translated to reserved value ( -1, 10 ). Later it is locally translated to the segment related the current user. 
</blockquote><p><table class="wikitable"><tr><td style="border: 1px solid #ccc; padding: 5px;">   <strong>Junction Point</strong> </td><td style="border: 1px solid #ccc; padding: 5px;"> <strong>Target</strong> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <strong>\CurrentUser</strong> </td><td style="border: 1px solid #ccc; padding: 5px;"> \RootStorage\Users\<i>&lt;&lt;CurrentUserId&gt;&gt;</i> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <strong>\LocalMachine</strong> </td><td style="border: 1px solid #ccc; padding: 5px;"> \RootStorage\Users\<i>&lt;&lt;ComputerName&gt;&gt;</i> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <strong>\RootStorage</strong> </td><td style="border: 1px solid #ccc; padding: 5px;"> The root section of file <i>treebase.dat</i> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <strong>\RootStorage\Users</strong> </td><td style="border: 1px solid #ccc; padding: 5px;"> The root section of file <i>users.dat</i> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <strong>\Databases</strong> </td><td style="border: 1px solid #ccc; padding: 5px;"> The root section of file <i>databases.dat</i> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <strong>\RootStorage\Databases</strong> </td><td style="border: 1px solid #ccc; padding: 5px;"> The root section of file <i>databases.dat</i> </td></tr> </table></p><p><table class="wikitable"><tr><td style="border: 1px solid #ccc; padding: 5px;"> <strong>Related Functions</strong> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>Junction::*</tt> functions </td></tr> </table></p><hr/><h3><a name="Security_Manager"></a>Security Manager<a href="#Security_Manager" class="section_anchor"></a></h3><blockquote>Each section has an associated entity about <i>security attributes</i>. In fact it is managed at segment layer - each dynamically created segment has an associated information about its <i>security attributes</i>. The security attributes are stored in a special purpose segment, one for each storage. The users are identified by internal UIDs represented in UUID format. 
</blockquote><p><table class="wikitable"><tr><td style="border: 1px solid #ccc; padding: 5px;"> <strong>Related Functions And Classes</strong> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>Security::Manager::*</tt> functions </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>Security::TSecurityAttributes</tt> </td></tr> </table></p><hr/><h3><a name="Session_Management_And_Authentication_Services"></a>Session Management And Authentication Services<a href="#Session_Management_And_Authentication_Services" class="section_anchor"></a></h3><blockquote>This is an intermediate layer between OS users and the <a href="#Security_Manager">security manager</a>. It translates the OS user IDs to the internal IDs and <i>vice versa</i>. Besides it is responsible for proper initialization of <a href="#Junction_Mechanism">junction points</a> for sections <i>\CurrentUser</i> and <i>\LocalMachine</i>. 
</blockquote><p><table class="wikitable"><tr><td style="border: 1px solid #ccc; padding: 5px;"> <strong>Related Functions</strong> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>Security::Facade::*</tt> functions </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>Session::*</tt> functions </td></tr> </table></p><hr/><h3><a name="System_Status"></a>System Status<a href="#System_Status" class="section_anchor"></a></h3><blockquote>It is responsible for showing the information about system resources in  the <i>\System\Status</i> section. The daemon thread periodically analyses the internal status table and updates the corresponding in-memory sections. 
</blockquote><p><table class="wikitable"><tr><td style="border: 1px solid #ccc; padding: 5px;"> <strong>Related Functions And Classes</strong> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>System::TSystemStatus</tt> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>System::addSession</tt> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>System::removeSession</tt> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>System::addDatabase</tt> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>System::removeDatabase</tt> </td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"> <tt>System::setAlarm</tt> </td></tr> </table></p>

</body>
</html>